#include "list.h"
#include <stdio.h>


void listInit(thelist *xlist)
{

    xlist->count = 0;
    xlist->head = NULL;
    xlist->tail = NULL;
    xlist->SaveNode = NULL;

}


void Insertfirst(thelist *xlist, list_node *newnode)
{
    xlist->head = newnode;
    xlist->tail = newnode;
    newnode->prev = (list_node *)xlist;
    newnode->next = newnode;

    xlist->SaveNode = xlist->head;
}


void Inserthead(thelist *xlist, list_node *newnode)
{
    newnode->prev = (list_node*)xlist;
    newnode->next = xlist->head;

    xlist->head->prev = newnode;

    xlist->head = newnode;
    xlist->tail->next = newnode;

    xlist->SaveNode = xlist->head;
}

void Inserttail(thelist *xlist, list_node *newnode)
{
    newnode->prev = xlist->tail;
    newnode->next = xlist->tail->next;

    xlist->tail->next = newnode;

    xlist->tail = newnode;


}


void Insertmiddle(thelist *xlist, list_node *newnode)
{
    list_node *findhelp;

    for(findhelp = xlist->head;findhelp->next->value <= newnode->value; findhelp = findhelp->next)
    {
        //finding...
    }

    newnode->prev = findhelp;
    newnode->next = findhelp->next;

    findhelp->next->prev = newnode;

    findhelp->next = newnode;


}

/* use the table to record all condition,separate the judgment conditions (like if else)  and excution

*/

uint8_t control(thelist *xlist , list_node *newnode)
{

    uint8_t rt = 0;

    if(xlist->count== 0)       return rt;
    rt += 1;

    if( newnode->value <= xlist->head->value)   return rt;
    rt += 1;

    if( newnode->value >= xlist->tail->value)    return rt;
    rt += 1;

    if( ( ( newnode->value) > (xlist->head->value)  ) && (newnode->value < xlist->tail->value) )  return rt;


}


void dataflow(uint8_t rt,thelist *xlist, list_node *newnode)
{
    void (*listInsert[])(thelist *xlist, list_node *newnode) = {
            Insertfirst,
            Inserthead,
            Inserttail,
            Insertmiddle,
    };
    listInsert[rt](xlist, newnode);

}



/*for same priority task,the task that hava minster usetime ,it will be excute early.greedy algorithm!

*/
void list_add(thelist *xlist, list_node *newnode)
{

    uint8_t op = control(xlist,newnode);
    dataflow(op,xlist, newnode);

    xlist->count += 1;
}

void remove_last( thelist *xlist, list_node *rmnode )
{
    xlist->head = NULL;
    xlist->tail = NULL;
    xlist->SaveNode = NULL;

    rmnode->prev = NULL;
    rmnode->next = NULL;

}

void remove_head( thelist *xlist, list_node *rmnode )
{
    xlist->head = rmnode->next;
    xlist->tail->next = rmnode->next;
    rmnode->next->prev = rmnode->prev;

    xlist->SaveNode = xlist->head;
}

void remove_middle( thelist *xlist, list_node *rmnode )
{
    rmnode->prev->next = rmnode->next;
    rmnode->next->prev = rmnode->prev;
}

void remove_tail( thelist *xlist, list_node *rmnode )
{
    rmnode->prev->next =  rmnode->next;
    xlist->tail = rmnode->prev;
}


uint8_t movecontrol(thelist *xlist , list_node *rmnode)
{
    uint8_t rt = 0;

    if( xlist->count == 1)          return  rt;
    rt += 1;

    if(xlist ->head == rmnode)       return rt;
    rt +=1;

    if( rmnode == xlist->tail)   return rt;
    rt += 1;

    if( ( ( rmnode->value) >= (xlist->head->value)  ) && (rmnode->value <= xlist->tail->value) )   return rt;

}


void moveflow(uint8_t rt,thelist *xlist, list_node *rmnode)
{
    void (*listremove[])(thelist *xlist, list_node *rmnode) = {
            remove_last,
            remove_head,
            remove_tail,
            remove_middle
    };
    listremove[rt](xlist, rmnode);
}

void list_remove(thelist *xlist, list_node *rmnode)
{
    uint8_t op = movecontrol(xlist,rmnode);
    moveflow(op,xlist, rmnode);

    xlist->count -= 1;
}



void oper_Creat(list_operation *ope)
{
     ope->Init = (void *)listInit;
     ope->add  = (void *)list_add;
     ope->remove =(void *) list_remove;

}





/*
*
*
here is test
***

thelist Readytasklist[ config_max_priori ];

list_node newreadynode0;

int main()
{

    newreadynode0.value = 3;

    listInit(&Readytasklist[0]);
    list_add(&Readytasklist[0],&newreadynode0);

    return 0;
}

*/







