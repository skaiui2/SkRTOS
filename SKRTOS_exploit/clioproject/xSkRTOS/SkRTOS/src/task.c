
#include"task.h"
#include "heapmem.h"
#include <stdint.h>
#include <stddef.h>
#include "port.h"


Error_help(task)

Readylist TReadylist;


Delaylist CommDelaylist;
Delaylist OverDelaylist;
Delaylist *DelaylistSelf = &CommDelaylist;

Suspendlist TSuspendlist;
Blocklist TBlocklist;



__attribute__((used)) TCB_struct volatile *CurrentTCB = NULL;
static volatile uint32_t xTickCountMAX = ( uint32_t ) 0xffffffffUL;
static volatile uint32_t NowTickCount = ( uint32_t ) 0;

extern TCB_struct *tcbTask1;
extern TCB_struct *tcbTask2;



void ReadylistInit( void )
{
    uint32_t i = config_max_priori - 1;
    while( i != 0)
    {
        listInit(&(TReadylist.Readylists[i]));
        i--;
    }

}


void ALLlistInit( void )
{
    ReadylistInit();

    listInit( &CommDelaylist.xlist );
    listInit( &OverDelaylist.xlist );
    listInit( &TSuspendlist.xlist );
    listInit( &TBlocklist.xlist );

}



void ReadyListAdd( TCB_struct *self )
{
    CurrentTCB = self;
    list_add( &(TReadylist.Readylists[self->priority]), &(self->tasknode) );
}


void ReadyListRemove( TCB_struct *self )
{

    list_remove( &(TReadylist.Readylists[self->priority]), &(self->tasknode) );

}




void DelaylistAdd( TCB_struct *self)
{
    const uint32_t constTicks = NowTickCount;
    uint32_t wakeTime = constTicks + self->TicksDelay;
    self->tasknode.value = wakeTime;

    if( wakeTime < constTicks)
    {
        list_add( &OverDelaylist , &(self->tasknode) );
    }
    else{
        list_add( &CommDelaylist , &(self->tasknode) );
        // i can find the max ticks by xlist->head
    }
}




void DelaylistRemove( TCB_struct *self)
{

    list_remove( DelaylistSelf, &(self->tasknode) );
}


uint32_t fDelayListMaxCount( Delaylist *self )
{
     uint32_t MaxCount =  self->xlist.head->value;
     return MaxCount;
}



void SuspendlistAdd( thelist *xlist , list_node *node)
{
    list_add( xlist , node);
}



void BlocklistAdd( thelist *xlist , list_node *node , TCB_struct *self)
{
    list_add( xlist , node);
}





void leisureTask( void )
{
    uint32_t count = 0;
    count++;


}

void *leisure_handle;
void lei_taskInit( void )
{
    TCB_struct *self;
    leisure_handle = TaskCreat( (Taskfunction)leisureTask,
                                      256,
                                      &self
    );

    ReadyListAdd( self );


}







void *Stack_init(    Taskfunction function_t,
                        uint32_t *pStack,
                        uint32_t *tStack,
                        const   uint32_t Stack_size,
                        TCB_struct **self
                    )
{
    uint32_t *topStack;
    void *pxreturn = NULL;
    
    topStack = ( uint32_t *) heap_malloc( ( ( ( size_t ) Stack_size ) * sizeof( uint32_t * ) ) );
    *pStack = (uint32_t)topStack;
    topStack = (uint32_t *)( (uint32_t)topStack + (Stack_size - (uint32_t)1) );
    topStack = ( uint32_t *) (((uint32_t)topStack) & (~((uint32_t) aligment_byte)));
    pxreturn = Init_Stack(topStack,self,function_t);

#ifndef config_error_print

#else

    if(pxreturn == NULL)
    {
        task_Error();
    }

#endif
    *tStack = (uint32_t)pxreturn;

    return pxreturn;
    
}


TCB_struct *TCB_init(     Taskfunction function_t,
                        uint32_t *pStack,
                        uint32_t *tStack,
                        TCB_struct **self
                    )
{
    (*self) = (TCB_struct *)heap_malloc(sizeof(TCB_struct));

    (*self)->function_t = function_t;
    (*self)->topStack  = (uint32_t *) *tStack;
    (*self)->startStack = (uint32_t *)*pStack;


    return *self;

}


extern uint32_t count;


void __attribute__((always_inline)) vTaskSwitchContext( void )
{
    //CurrentTCB = tcbTask2;

    if(CurrentTCB == tcbTask1)
    {
        CurrentTCB = tcbTask2;
    }
    else
    {
        CurrentTCB = tcbTask1;
    }


/*
    if( count > 500) {
        CurrentTCB = tcbTask1;
    }
    else
    {
        CurrentTCB = tcbTask2;
    }
*/


}






void *TaskCreat(  Taskfunction function_t,
                  const   uint32_t Stack_size,
                  TCB_struct **self
                  )
{
    uint32_t *task_leisure = NULL;
    TCB_struct *NewTcb = NULL;

    //to change the value of pStack and  tStack,so malloc memory!
    uint32_t *pStack = heap_malloc(sizeof (uint32_t *));
    uint32_t *tStack = heap_malloc(sizeof (uint32_t *));

    //the growth is up to down!
    task_leisure = Stack_init( function_t ,pStack,tStack,Stack_size,self );
    NewTcb = TCB_init(  function_t, pStack, tStack, self);

    //free memory!
    heap_free(pStack);
    heap_free(tStack);



    ReadyListAdd(*self);

    return *self;
}


void TaskDelay( const uint32_t TicksDelay )
{
     TCB_struct  *NowTCB;
     NowTCB = CurrentTCB;
     NowTCB->TicksDelay = TicksDelay;
     DelaylistAdd( NowTCB );
     ReadyListRemove( NowTCB );

    contextSwitchTriger();

}


void TaskDelayTimeCheck( void )
{
    list_node *listnode;
    TCB_struct *self;
    uint32_t MaxCount;
    uint32_t UpdateTickCount;

    if( ( ListNodeNumber(DelaylistSelf) ) == 0)
    {
        contextTrig();
    }

    if( UpdateTickCount == ( uint32_t) 0UL)
    {
        *DelaylistSelf = OverDelaylist;
    }

    listnode = DelaylistSelf->xlist.head;
    MaxCount = fDelayListMaxCount( DelaylistSelf );
    UpdateTickCount = NowTickCount + 1;


    if( UpdateTickCount >= MaxCount )
    {
        while( listnode->value >= UpdateTickCount )
        {
            self = container_of( listnode,TCB_struct,tasknode);
            DelaylistRemove(self);
            ReadyListAdd(self);
            if( listnode->next != DelaylistSelf->xlist.tail)
            {
                listnode = listnode->next;
            }
            else{
                break;
            }
        }
    }
    contextTrig();
}





