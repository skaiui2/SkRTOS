
#include "port.h"
#include "error.h"
#include "task.h"



Error_help(port)


#define Init_XPSR   0x01000000UL
#define ThumbFun_adderss                ( ( uint32_t ) 0xfffffffeUL )

#define LR_error      port_Error


uint32_t * Init_Stack(  uint32_t * topStack,
                            TCB_struct **self,
                            Taskfunction function_t )
{

    Stack_register *Stack;
     /*the regiters is placed in the end of array.we need 16 word to place them!
     *
     * *The registers in the structure correspond to the placement
     of 16 register parameters from low addresses to high addresses
     *
     * */

    topStack -= 16;
    Stack = (Stack_register *)topStack;

    Stack->xPSR = Init_XPSR;                                   
    
    Stack->PC = ( ( uint32_t ) function_t ) & ThumbFun_adderss; 
    
    Stack->LR = ( uint32_t ) LR_error;             
                                                     
    Stack->r0 = ( uint32_t ) self;

    return topStack;

}


#define Stack_pre( void )                                       \
{                                                               \
    __asm volatile(                                             \
    /*  the r3 is two level pointer,r3 get the address of pxcurrent,although the pxcurrent change the   \
    * task function,it can **r3,then get the present pxcurrent.Very good.It can save register!!! */     \
            "	mrs r0, psp							\n"         \
            "	isb									\n"         \
            "	ldr	r3, pxCurrentTCBConst			\n"         \
            "	ldr	r2, [r3]						\n"         \
            "	stmdb r0!, {r4-r11}					\n"         \
            "	str r0, [r2]						\n"         \
            "pxCurrentTCBConst: .word pxCurrentTCB	\n"         \
            );                                                  \
}


#define Switch_tcb( void )                                       \
{                                                               \
    __asm volatile(                                             \
            "	stmdb sp!, {r3, r14}				\n"         \
            "	mov r0, %0							\n"         \
            "	msr basepri, r0						\n"         \
            "	bl vTaskSwitchContext				\n"         \
            "	mov r0, #0							\n"         \
            "	msr basepri, r0						\n"         \
            "	ldmia sp!, {r3, r14}				\n"         \
            ::"i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )      \
            );                                                  \
}



#define Stack_next( void )                                      \
{                                                               \
    __asm volatile                                              \
            (                                                   \
            "	ldr r1, [r3]						\n"         \
            "	ldr r0, [r1]						\n"         \
            "	ldmia r0!, {r4-r11}					\n"         \
            "	msr psp, r0							\n"         \
            "	isb									\n"         \
            "	bx r14								\n"         \
            "	.align 4							\n"         \
            );                                                  \
}


static void xStartFirstTask( void )
{
    __asm volatile (
            " ldr r0, =0xE000ED08 	\n"/* Use the NVIC offset register to locate the stack. */
            " ldr r0, [r0] 			\n"
            " ldr r0, [r0] 			\n"
            " msr msp, r0			\n"/* Set the msp back to the start of the stack. */
            " cpsie i				\n"/* Globally enable interrupts. */
            " cpsie f				\n"
            " dsb					\n"
            " isb					\n"
            " svc 0					\n"/* System call to start first task. */
            " nop					\n"
            " .ltorg				\n"
            );
}




void xSVCHandler( void )
{
    __asm volatile (
            "	ldr	r3, pxCurrentTCBConst2		\n"// Restore the context.
            "	ldr r1, [r3]					\n"//Use pxCurrentTCBConst to get the pxCurrentTCB address.
            "	ldr r0, [r1]					\n"// The first item in pxCurrentTCB is the task top of stack.
            "	ldmia r0!, {r4-r11}				\n"// Pop the registers that are not automatically saved on exception entry and the critical nesting count.
            "	msr psp, r0						\n"// Restore the task stack pointer.
            "	isb								\n"
            "	mov r0, #0 						\n"
            "	msr	basepri, r0					\n"
            "	orr r14, #0xd					\n"
            "	bx r14							\n"
            "									\n"
            "	.align 4						\n"
            "pxCurrentTCBConst2: .word pxCurrentTCB				\n"
            );
}




long xStartScheduler( void )
{
   
    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;
    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;


    /* Start the first task. */
    xStartFirstTask();



    return 0;
}





void  Pcontext( void )
{
    *( ( volatile uint32_t * ) 0xe000ed04 ) = 1UL << 28UL;

}


inline void contextSwitchTriger(void) {
    __asm volatile (
            "LDR R0, =0xE000ED04\n"
            "MOV R1, #1\n"
            "LSL R1, R1, #28\n"
            "STR R1, [R0]\n"
            "dsb \n"
            "isb \n"
            :
            :
            : "memory"
            );
}


void xPendSVHandler( void )
{
    Stack_pre();
    Switch_tcb();
    Stack_next();
}




