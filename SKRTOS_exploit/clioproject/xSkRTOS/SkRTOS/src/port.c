
#include "port.h"
#include "task.h"


Error_help(port)


uint32_t * Init_Stack(  uint32_t * topStack,
                            TCB_struct **self,
                            Taskfunction function_t )
{


     /*the regiters is placed in the end of array.we need 16 word to place them!
     *
     * *The registers in the structure correspond to the placement
     of 16 register parameters from low addresses to high addresses
     *
     * */

/*
    Stack_register *Stack;
    topStack -= 16;
    Stack = (Stack_register *)topStack;

    Stack->xPSR = Init_XPSR;                                   
    
    Stack->PC = ( ( uint32_t ) function_t ) & ThumbFun_adderss; 
    
    Stack->LR = ( uint32_t ) LR_error;             
                                                     
    Stack->r0 = ( uint32_t ) self;

    return topStack;

*/
    topStack--;
    *topStack = Init_XPSR;
    topStack--;
    *topStack = ( ( uint32_t ) function_t ) & ThumbFun_adderss;
    topStack--;
    *topStack = ( uint32_t ) LR_error;
    topStack -= 5;
    *topStack = ( uint32_t ) self;
    topStack -= 8;

    return topStack;

}


#define Stack_pre( void )                                       \
{                                                               \
    __asm volatile(                                             \
    /*  the r3 is two level pointer,r3 get the address of pxcurrent,although the pxcurrent change the   \
    * task function,it can **r3,then get the present pxcurrent.Very good.It can save register!!! */     \
            "	mrs r0, psp							\n"         \
            "	isb									\n"         \
            "	ldr	r3, NewTcbAddress			    \n"         \
            "	ldr	r2, [r3]						\n"         \
            "	stmdb r0!, {r4-r11}					\n"         \
            "	str r0, [r2]						\n"                             \
            ".align 4	    \n"         \
            "NewTcbAddress: .word CurrentTCB	    \n"         \
            );                                                  \
}


#define Switch_tcb( void )                                       \
{                                                               \
    __asm volatile(                                             \
            "	stmdb sp!, {r3, r14}				\n"         \
            "	mov r0, %0							\n"         \
            "	msr basepri, r0						\n"         \
            "	bl vTaskSwitchContext				\n"         \
            "	mov r0, #0							\n"         \
            "	msr basepri, r0						\n"         \
            "	ldmia sp!, {r3, r14}				\n"          \
            ".align 4	    \n"                                 \
            ::"i" ( configShieldInterPriority )                  \
            );                                                  \
}


#define Stack_next( void )                                      \
{                                                               \
    __asm volatile                                              \
            (                                                   \
            "	ldr r1, [r3]						\n"         \
            "	ldr r0, [r1]						\n"         \
            "	ldmia r0!, {r4-r11}					\n"         \
            "	msr psp, r0							\n"         \
            "	isb									\n"         \
            "	bx r14								\n"         \
            "	.align 4							\n"         \
            );                                                  \
}


static void xStartFirstTask( void )
{
    __asm volatile (
            " ldr r0, =0xE000ED08 	\n"/* Use the NVIC offset register to locate the stack. */
            " ldr r0, [r0] 			\n"
            " ldr r0, [r0] 			\n"
            " msr msp, r0			\n"/* Set the msp back to the start of the stack. */
            " cpsie i				\n"/* Globally enable interrupts. */
            " cpsie f				\n"
            " dsb					\n"
            " isb					\n"
            " svc 0					\n"/* System call to start first task. */
            " nop					\n"
            " .ltorg				\n"
            );
}




void xSVCHandler( void )
{
    __asm volatile (
            "	ldr	r3, pxCurrentTCBConst2		\n"/* Restore the context. */
            "	ldr r1, [r3]					\n"/* Use pxCurrentTCBConst to get the pxCurrentTCB address. */
            "	ldr r0, [r1]					\n"/* The first item in pxCurrentTCB is the task top of stack. */
            "	ldmia r0!, {r4-r11}				\n"/* Pop the registers that are not automatically saved on exception entry and the critical nesting count. */
            "	msr psp, r0						\n"/* Restore the task stack pointer. */
            "	isb								\n"
            "	mov r0, #0 						\n"
            "	msr	basepri, r0					\n"
            "	orr r14, #0xd					\n"
            "	bx r14							\n"
            "									\n"
            "	.align 4						\n"
            "pxCurrentTCBConst2: .word CurrentTCB				\n"
            );
}






void  Pcontext( void )
{
    *( ( volatile uint32_t * ) 0xe000ed04 ) = 1UL << 28UL;

}



void __attribute__((always_inline)) contextSwitchTriger(void) {
    __asm volatile (
            "LDR R0, =0xE000ED04\n"
            "MOV R1, #1\n"
            "LSL R1, R1, #28\n"
            "STR R1, [R0]\n"
            "dsb \n"
            "isb \n"
            :
            :
            : "memory"
            );
}




void xPendVHandler( void )
{
    Stack_pre();
    Switch_tcb();
    Stack_next();
}



void xPendSVHandler( void )
{
    /* This is a naked function. */
    __asm volatile
            (
            "	mrs r0, psp							\n"
            "	isb									\n"
            "										\n"
            "	ldr	r3, pxCurrentTCBConst			\n"/* Get the location of the current TCB. */
            "	ldr	r2, [r3]						\n"
            "										\n"
            "	stmdb r0!, {r4-r11}					\n"/* Save the remaining registers. */
            "	str r0, [r2]						\n"/* Save the new top of stack into the first member of the TCB. */
            "										\n"
            "	stmdb sp!, {r3, r14}				\n"
            "	mov r0, %0							\n"
            "	msr basepri, r0						\n"
            "	bl vTaskSwitchContext				\n"
            "	mov r0, #0							\n"
            "	msr basepri, r0						\n"
            "	ldmia sp!, {r3, r14}				\n"
            "										\n"/* Restore the context, including the critical nesting count. */
            "	ldr r1, [r3]						\n"
            "	ldr r0, [r1]						\n"/* The first item in pxCurrentTCB is the task top of stack. */
            "	ldmia r0!, {r4-r11}					\n"/* Pop the registers. */
            "	msr psp, r0							\n"
            "	isb									\n"
            "	bx r14								\n"
            "										\n"
            "	.align 4							\n"
            "pxCurrentTCBConst: .word CurrentTCB	\n"
            ::"i" ( configShieldInterPriority )
            );
}


void Systicknit( void )
{
    Systick_struct *Systick;
    Systick = (Systick_struct *)portNVIC_SYSTICK_ADDRESS;
    /* Stop and clear the SysTick. */
    Systick->CTRL = 0UL;
    Systick->VAL = 0UL;

    /* Configure SysTick to interrupt at the requested rate. */
    Systick->LOAD = ( configSysTickCLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
    Systick->CTRL = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
}



/* Constants required to manipulate the core.  Registers first... */
#define portNVIC_SYSTICK_CTRL_REG             ( *( ( volatile uint32_t * ) 0xe000e010 ) )
#define portNVIC_SYSTICK_LOAD_REG             ( *( ( volatile uint32_t * ) 0xe000e014 ) )
#define portNVIC_SYSTICK_CURRENT_VALUE_REG    ( *( ( volatile uint32_t * ) 0xe000e018 ) )




__attribute__( ( weak ) ) void vPortSetupTimerInterrupt( void )
{
    portNVIC_SYSTICK_CTRL_REG = 0UL;
    portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;

    /* Configure SysTick to interrupt at the requested rate. */
    portNVIC_SYSTICK_LOAD_REG = ( configSysTickCLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
    portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
}



#include "task.h"
long xStartScheduler( void )
{

    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;
    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;
    //portNVIC_SHPR2_REG = 0;// the svc must run first!So its priority must highest!

    vPortSetupTimerInterrupt();


    /* Start the first task. */
    xStartFirstTask();


    vTaskSwitchContext();
    port_Error();


    return 0;
}





uint32_t xEnterCritical( void ) __attribute__((always_inline));
uint32_t xEnterCritical( void )
{
    uint32_t xReturn;

    __asm volatile(
            " cpsid i               \n"
            " mov r0, %0            \n"
            " mrs r0, basepri       \n"
            " mov r1, %1            \n"
            " msr basepri, r1       \n"
            " dsb                   \n"
            " isb                   \n"
            " cpsie i               \n"
            : "=r" (xReturn)        // Output operand
            : "i" (configShieldInterPriority) // Input operand
            : "memory"              // Clobbered list
            );

    return xReturn;
}

void xEixtCritical( uint32_t xReturn ) __attribute__((always_inline));
void xEixtCritical( uint32_t xReturn )
{
    __asm volatile(
            " cpsid i               \n"
            " mov r0, %0            \n"
            " msr basepri, r0       \n"
            " dsb                   \n"
            " isb                   \n"
            " cpsie i               \n"
            :
            : "r" (xReturn)
            : "memory"
            );
}




void xSystickHandler( void )
{
    uint32_t xReturn = xEnterCritical();

    TaskDelayTimeCheck();

    xEixtCritical(xReturn);
}






















