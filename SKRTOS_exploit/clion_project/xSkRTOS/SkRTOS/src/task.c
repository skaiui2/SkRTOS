
#include"task.h"
#include "heapmem.h"
#include <stdint.h>
#include <stddef.h>
#include "port.h"

Error_help(task)

Readylist TReadylist;
Suspendlist TSuspendlist;
Blocklist TBlocklist;
list_operation listopt;

TCB_struct  *pxCurrentTCB = NULL;

extern TCB_struct *tcbTask1;
extern TCB_struct *tcbTask2;



void ReadylistInit( void )
{
    uint32_t i = config_max_priori - 1;
    while( i != 0)
    {
        listopt.Init(&(TReadylist.Readylists[i]));
        i--;
    }

}


void ALLlistInit( void )
{
    oper_Creat( &listopt );
    ReadylistInit();
    listopt.Init( &TSuspendlist.xlist );
    listopt.Init( &TBlocklist.xlist );

}


void ReadylistAdd( thelist *xlist , list_node *node, TCB_struct *self)
{
    pxCurrentTCB = self;
    listopt.add( xlist , node);   
}


void vTaskSwitchContext( void )
{

    if(pxCurrentTCB == tcbTask1)
    {
        pxCurrentTCB = tcbTask2;
    }
    else
    {
        pxCurrentTCB = tcbTask1;
    }


}


void SuspendlistAdd( thelist *xlist , list_node *node)
{
    listopt.add( xlist , node);   
}


void BlocklistAdd( thelist *xlist , list_node *node , TCB_struct *self)
{
    listopt.add( xlist , node);   
}





void *Stack_init(    Taskfunction function_t,
                        uint32_t *pStack,
                        uint32_t *tStack,
                        const   uint32_t Stack_size,
                        TCB_struct **self
                    )
{
    uint32_t *topStack;
    void *pxreturn = NULL;
    
    topStack = ( uint32_t *) heap_malloc( ( ( ( size_t ) Stack_size ) * sizeof( uint32_t * ) ) );
    *pStack = (uint32_t)topStack;
    topStack = (uint32_t *)( (uint32_t)topStack + (Stack_size - (uint32_t)1) );
    topStack = ( uint32_t *) (((uint32_t)topStack) & (~((uint32_t) aligment_byte)));
    pxreturn = Init_Stack(topStack,self,function_t);

#ifndef config_error_print

#else

    if(pxreturn == NULL)
    {
        task_Error();
    }

#endif
    *tStack = (uint32_t)pxreturn;

    return pxreturn;
    
}


TCB_struct *TCB_init(     Taskfunction function_t,
                        uint32_t *pStack,
                        uint32_t *tStack,
                        TCB_struct **self
                    )
{
    (*self) = (TCB_struct *)heap_malloc(sizeof(TCB_struct));

    (*self)->function_t = function_t;
    (*self)->topStack  = (uint32_t *) *tStack;
    (*self)->startStack = (uint32_t *)*pStack;

    listopt.Init( &((*self)->tasknode) );

    return *self;

}




void *TaskCreat(  Taskfunction function_t,
                  const   uint32_t Stack_size,
                  TCB_struct **self
                  )
{
    uint32_t *task_leisure = NULL;
    TCB_struct *NewTcb = NULL;

    //to change the value of pStack and  tStack,so malloc memory!
    uint32_t *pStack = heap_malloc(sizeof (uint32_t *));
    uint32_t *tStack = heap_malloc(sizeof (uint32_t *));

    //the growth is up to down!
    task_leisure = Stack_init( function_t ,pStack,tStack,Stack_size,self );
    NewTcb = TCB_init(  function_t, pStack, tStack, self);

    //free memory!
    heap_free(pStack);
    heap_free(tStack);



/*
    uint32_t *topStack;
    TCB_struct *xtcb = NULL;

    topStack = ( uint32_t *)heap_malloc( ( ( ( size_t ) Stack_size ) * sizeof( uint32_t * ) ) );
    pStack = (uint32_t *)topStack;
    topStack = (uint32_t *)( (uint32_t)topStack + (Stack_size - (uint32_t)1) );
    topStack = ( uint32_t *) (((uint32_t)topStack) & (~((uint32_t) aligment_byte)));
    xtcb = Init_Stack(topStack,NULL,function_t);
#if config_error_func

#else
    if(xtcb == NULL)
    {
        task_Error();
    }
#endif
    tStack = (uint32_t *)xtcb;


    //this is self class init !
    *self = heap_malloc(sizeof (int *));
    (*self)->function_t = function_t;
    (*self)->topStack  = (uint32_t *) tStack;
    (*self)->startStack = (uint32_t *) pStack;
*/

    listopt.Init( (list_node *)( &((*self)->tasknode) ) );
    ReadylistAdd( &(TReadylist.Readylists[(*self)->priority]), &((*self)->tasknode) , *self);

    return *self;
}




